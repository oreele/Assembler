/* implementation of symbols table as linked list */#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "symbols.h"#include "consts.h"#include "assembler.h"#define INIT_COUNTER	0 /* the initialization value for a counter */int search_symbol (char *, int *);typedef struct node {	char *symbol;	int address;	int external:1;	int operation:2;	struct node *next;} list; /* a node of the symbol list */list *table = NULL; /* the head of the list *//*add_symbol: add a symbol. gets the name of the symbol: s, the value: val, and ext that sign if its external and op that sign if its point to a operation.returns 1 if succeed to add.*/int add_symbol (char *s, int val, int ext, int op) {	list *new_node; /* the new node for the list */	if(search_symbol(s, NULL)) { /* that symbol is exists */		fprintf(stderr, "label %s appears more than once\n", s);		return FAILURE;	}	new_node = malloc(sizeof(list)); /* allocation for a new node */	if(!new_node)		return FAILURE; /* can't accomplish allocation */	new_node->symbol = s;	new_node->address = val;	new_node->external = ext;	new_node->operation = op;	new_node->next = table;	table = new_node; /* add the node at the start of the list */	return SUCCESS; /* success */}/*search_symbol: gets a string s and a pointer to integer val and return 1 if found a symbol named s. If found, val turns to point on the value of the symbol (if value isnot null).*/int search_symbol (char *s, int *val) {	list *curr = table; /* a pointer to pass on the list */	while(curr) {		if(!strcmp(curr->symbol, s)) { /* the strings are equals */			if(val) *val = curr->address; /* if val isnot null, put the address there */			return YES; /* found */ 		}		else curr = curr->next;	}	return NO; /* not found */}/*change_address_data_symbols: gets a number no and add the address of each data symbol that number.*/void change_address_data_symbols (int no) {	list *curr = table; /* a pointer to pass on the list */	while(curr) {		if(curr->operation==0) /* curr is a data symbol */			(curr->address) += no;		curr = curr->next;	}}/*is_external: gets a string s of a symbol and returns if it is external (1 for yes, 0 for NO).ASSUMPTION: s is a name of symbol.*/int is_external (char *s) {	list *curr = table; /* a pointer to pass on the list */	while(curr) {		if(!strcmp(curr->symbol, s)) { /* the strings are equals */			return curr->external; /* returns if curr is external */		}		else curr = curr->next;	}	return ERR;}/*free_list: free the memory of the list nodes and strings*/void free_list () {	list *curr = table /* a pointer to pass on the list */, *temp /* a temporary pointer to hand the next node while we free the previous */;	while(curr) { /* pass the list */		free(curr->symbol); /* free the symbol string */		temp = curr;		curr = curr->next;		free(temp); /* free the node itself */	}	table = NULL; /* reset the list to NULL */}/*no_internal: returns the number of internals symbols.*/int no_internal () {	int counter = INIT_COUNTER; /* counts the internals */	list *curr = table; /* a pointer to pass on the list */	while(curr) {		if(curr->external==NO) /* curr is internal */			counter++;		curr = curr->next;	}	return counter;}/*randomize_label: returns a randomized internal symbol address.*/int randomize_label () {	int bound = no_internal() /* the upper bound value to random */, random /* gets the random value of internal symbols from the start */;	list *curr = table; /* pointer to pass on the list */	if(!bound)		return ERR; /* don't have any internal labels */	srand(time(NULL));	random = rand() % (bound); /* generate the random value */	while(random>0) { /* step random steps of internal symbols from the start */		if(!curr->external)			random--;		if(random>0) curr = curr->next;	}	return curr->address;}